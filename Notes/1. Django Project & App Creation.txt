Hello, World!
Topic objective: In these text-based steps, we will create a Django project and a Django app that will display simple HTML.

Follow the steps below to get up and running.

Create a new project or workspace using the appropriate template in your IDE.

TIP: If you are using our recommended IDE, ensure you use the standard template file to create your workspace.

Creating your repo
1. Give your repo a unique descriptive name that is based on the project. I have used django-project.

GitHub template
2. Click on Create repository from template.

Create GitHub repo from template
3. Open in your preferred IDE.

Open repo in cloud IDE workspace
4. In the main menu, click on Terminal > New Terminal.

Open a new terminal tab
Installing packages
5. Type the following command in the terminal to install the Django Python package:

pip3 install Django~=4.2.1
Note: ~=4.2.1 installs any package version greater than or equal to 4.2.1 but less than 4.3

Install django package
6. Once the package is installed, add it to the requirements.txt file with the following command:

pip3 freeze --local > requirements.txt
Opening requirements.txt
7. It's good practice to check what packages have been installed. When you look in the requirements file, you can see that three packages were installed.

Verifying package versions
Creating a Django project 
8. Return to the terminal. In the terminal, create a Django project called my_project in the current directory.

Important: Remember that the shortcut to refer to the current directory is a single dot . at the end of the command.

django-admin startproject my_project .
Note: Check in the explorer tab to see that the my_project project structure has been created.

Opening the project directory
9. Return to the terminal and start the Django server with the following command:

python3 manage.py runserver
Starting the server
10. Click on Open Browser.

Open the browser
11. This opens a scary-looking yellow error screen, don't worry! Your server is running properly. This error is telling you that, for security reasons, Django doesn't recognise the hostname - the server name your project is running on.

Disallowed host Django error
12. Select and copy the hostname after "Invalid HTTP_HOST header:". In this example, that is '8000-nielmc-django-project-0kylrta3cs.us2.codeanyapp.com' - you can include the quotes.

Copy the host name
13. In the my_project/settings.py file, paste the hostname between the square brackets of ALLOWED_HOSTS and save. For the above example, this would look like:

ALLOWED_HOSTS = ['8000-nielmc-django-project-0kylrta3cs.us2.codeanyapp.com']
Add to ALLOWED_HOSTS
14. Now if you return to the browser tab and refresh you will see a bare-bones Django project.

Note: Return to the terminal and use ctrl-c to kill the server.

Django empty install screen
Creating a Django app
15. Now we have a Django project created, we need to make an app. To do this, we use the manage.py file. In the terminal, type:

python3 manage.py startapp hello_world
Note: Check the explorer panel to see the new hello_world app directory has been created.

Open app directory
Creating Views
16. In hello_world/views.py, below from django.shortcuts import render, type:

from django.http import HttpResponse
Import HttpResponse
17. Below the # Create your views here. comment, create the following Python function named index. Inside the function, we are returning a simple HTTP response.

Write function-based view
18. Within parentheses after HttpResponse add the string "Hello, world!"

Type string to be displayed
Creating our URLs
19. In my_project/urls.py, You'll see that this urls.py file already has some content in it. That's fine, we will need that in future. Let's include the view we just created.

Add a URL pattern path
20. Import the include function by appending it after a comma to the existing django.urls import.

Append include to import
21. Below that, import the views from the hello_world app.

from hello_world import views as index_views
Here we are giving the hello_world/views.py file an alias of index_views. In a one-app project, this would not be strictly necessary. However, in a multiple-app project using descriptive alias names makes your urls.py file much easier to read and maintain.

Import views
22. Above the admin pattern in urlpatterns add:

path('', index_views.index, name='index'),
Add blank string path for domain level URL
settings.py
23. Finally, we just need to add our app to the settings.py file to connect the app to the project. For our simple app, this is not strictly necessary, but it's good practice and will be required later on when app models are connecting to databases.

To connect the app you will need to scroll down through the my_project/settings.py file to find the INSTALLED_APPS list.

Add app to settings
24. Append 'hello_world', to the end of the list of INSTALLED_APPS.

Note: Don't forget the comma at the end.

Use trailing comma in INSTALLED_APPS
Testing our app
25. Always make sure to always save all your files before running the project. You can also take this opportunity to git add, commit and push your work.

Save all files
26. Open a browser window by returning to the terminal tab and running the Django server with the same command as you did previously, and now you can see the text Hello, world! In the browser.


Project & apps
The very first thing we did, after installing Django, was to create a project and an app.

Challenge
First, let's get familiar with the file structure of a Django project and app.

Important: You should refer to the steps you covered in the previous topic, and your code, to answer the questions below.

Creating a project:

From the previous steps, what was the command to create our project? What is the significance of the dot at the end of the command?
Check your repo, ignoring the hello_world directory for now, what other directories are there?
Can you find the settings.py file? In settings.py, how many installed apps, not including hello_world, are included in the Project?
Creating an app:

From the previous steps, what was the command to create our Hello World app?
What directory was created, and what files do you see inside it?
Explanation
Creating a project:

The django-admin startproject command expects to see a project name followed by a directory name. For example:
django-admin startproject project_name directory_name
In our case, the directory name is shown as a dot. The dot tells us that the project should be created in the current directory.
django-admin startproject my_project .
Note: If you leave the dot off and just type django-admin startproject my_project then it will create the project, my_project, inside a directory called my_project. If that happens, simply delete the directory and run the correct startproject command again.
When the project is created, you should see the directory structure similar to the following:
manage.py
my_project/
  init__.py
  settings.py
  urls.py
  asgi.py
  wsgi.py
You'll learn more about these files in future lessons, but for now key files to note are: manage.py, settings.py, and urls.py.
You can see that the settings.py file is in the my_project directory. There are six apps listed in INSTALLED_APPS; this is the default for any new project.
Creating an app:

The command we used to start the Hello World app was:
python3 manage.py startapp hello_world
The command created an app Inside the hello_world directory. In there, you will see files such as models.py and views.py. These will be the main files you will use to build a project.
Creating a project
The top level in Django is a project. A project is like a container for everything we want to do. By default, the project contains a settings file and some other administrative files.

Important files in our project folder:

settings.py: this file contains the project-wide settings, such as installed apps and database connection information, among other things.
manage.py: this file is in the root directory, above the project folder. It is used to create apps, run our project and perform some database operations.
Creating an app
Inside the project, we create apps. We’ll go into this a bit deeper later on, but an app’s structure is like a Python package with multiple Python modules within a directory.

Simply put, apps are the building blocks of Django. They’re the things that actually do something, such as a blog, a to-do list, or a poll. A project can contain many, many apps. You could do everything you want with just one app, but for maintainability and good design practices, it is better to separate different functionality into different apps.

Important files in our apps folder:

models.py: our database models are stored here, which define the structure of the database used by our app.
views.py: this file contains the view code for our app. You’ve already created some view code to display a text response to the user.
Test your knowledge
Using the correct command, create a new app called about.
What directory was created?
Add the about app to INSTALLED_APPS in settings.py.
Solution
The correct command to create a new app called about is:

python3 manage.py startapp about
The app now lives in a directory called about.
The last entry in INSTALLED_APPS should be about. Don’t forget that this is a comma-separated list, so you might need to add a comma to the end of the app immediately above about.
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'hello_world',
    'about',
]
Remember to add your newly-created app to INSTALLED_APPS so that Django knows it exists. You don’t always need to do this for very simple apps like we are creating here, but as we introduce database models, it will become important. It’s best practice, then, to always add your newly-created app to INSTALLED_APPS in settings.py as soon as you’ve created it.

Review
Remembering how to create a project and, especially, how to create apps is a vital part of understanding Django. In the next topic, we will dive a bit deeper into how all the parts of an app and project connect together. We will start by analysing URLs.

Note: Remember to commit and push your code.

Investigating URLs
As you saw from the previous steps, Django has many moving parts. To clarify what happens when you make a request, let’s take a look at how URLs work in Django.

Challenge
To examine this in more detail:

Open the my_project/urls.py file. Change the path that we added from an empty string, '', to 'hello/', e.g.
path('hello/', index_views.index, name='index'),
Save the file then run your project again. Refresh the page in your browser. What happens?
What happens if you add /hello to the end of the URL? Why do you think this happened?
What do you think the index_views code does within the URLs path? i.e.
path('hello/', index_views.index, name='index'),
Hint: Check the views.py file.
Explanation
Your urlpatterns in urls.py should now look like this:
urlpatterns = [
    path('hello/', index_views.index, name='index'),
    path('admin/', admin.site.urls),
]
Note: Django checks each of the URLs in the urls.py file in order. For this simple project, it does not matter whether hello/ is above or below admin/. For more complex projects, though, you may need to give attention to the order in which your URLs appear. For the moment, just remember to keep admin/ at the bottom, as shown.
When you try to access the root or top-level directory, you will get an error that looks like this:
Error image
It looks scary and horrible, but all it is saying is that the URL could not be found. You’ll notice from the detail underneath the error message that the paths of hello/ and admin/ are registered, but that they did not match the URL you gave.
When you add /hello on to the end of your URL, the page loads correctly as before.
When you add a path like this to the urls.py file, we are telling Django that when the user inputs this specific URL, it should run the index function within the views.py linked to this path, e.g.
path('hello/',  index_views.index, name='index'),
Investigating URLs
Look at the Django Request Cycle image, which will help you to visualise what happens. This diagram is highly simplified. We will add to it as we go through the course. Here is a breakdown of the steps:

The user enters a URL to your site in their browser.
Django’s URL router checks to see if the URL matches any known URLs.
If the entered URL does not match anything in the urls.py files, then Django returns an error.
If it does match, then Django passes control to the view specified in the URL. In our case, the view is called index.
The view returns either a HttpResponse or a template. In our case, it returns a HttpResponse. We’ll look at creating full-featured HTML pages later.
Importing views
The first thing we need to do in our urls.py file is to import the views. We can then refer to these views in urlpatterns.

As you can see, close to the top of urls.py, we import the views from hello_world using this line:

from hello_world import views as index_views
When we import something in Python we can use the as keyword, this creates an alias, which is how we will refer to the import from now on. In this case, we will refer to the views we imported as index_views.

The path function
Then, the path function takes three arguments:

path('hello/', index_views.index, name='index'),
First is the URL pattern, which we have already discussed.
Then, the view to call. In our case, the index function from the views file we imported and aliased as index_views.
Finally, we have a friendly name for the view. We will see how we use this in template files later in the course.
IMPORTANT NOTE: As shown above, you must add the trailing / to your URL patterns, otherwise they will not work.

Test your knowledge
In the previous topic, we created a new app, about. Now, we’d like you to:

Give it some simple functionality by completing its views file.
Then wire it up with a URL.
Part 1 - Creating the about/views.py file:

Give the about app similar functionality to the hello_world app, except it should return a HttpResponse of "This would be the about page" instead.
The view name should be about_me.
Part 2 - Wiring up the URLs

Following the format we used to import our index views, import views from about and alias them as about_views.
Now add a path to the urlpatterns. The path should be 'about/'.
The second argument should follow a similar format to our homepage. Check the about/views.py file again if you need to see what the function is called.
Give it the name of 'about'.
When you have done that, run the project again, navigate to both the about/ and hello/ URLs and see if they still work.

Solution
Part 1 - Creating the about/views.py file:

In the about/views.py file.

from django.shortcuts import render
from django.http import HttpResponse

# Create your views here.
def about_me(request):
    return HttpResponse("This would be the about page")
Part 2: Wiring up the URLs:

Your my_project/urls.py file should now look like this:

from django.contrib import admin
from django.urls import path, include
from hello_world import views as index_views
from about import views as about_views

urlpatterns = [
    path('hello/', index_views.index, name='index'),
    path('about/', about_views.about_me, name='about'),
    path('admin/', admin.site.urls),
]
Running the project and navigating to the about/ URL should give you the following text:

This would be the about page

Review
Understanding URLs is an important part of getting Django to work properly. Using this method, we can create a URL scheme for our website so that products can live under the products/ URL, the contact page will be at contact/ and so on.

You will see more complex URL patterns as we progress throughout the course.

In our next topic, we will discuss the next part of the Django Request Cycle: the views.

Note: Remember to commit and push your code.

Inside a View
As we previously discussed, Django is a Model View Template framework. The flow of information between the models, views and templates can be seen in the image.

The view is the code that:

Creates, reads, updates or deletes data using the models.
Renders the template for the user.
Challenge
Take a look at the view function shown below:

def index(request):

   if request.method == "GET":
       return HttpResponse("This was a GET request")
   elif request.method == "POST":
       return HttpResponse("This was a POST request")
What is the argument that is being passed to the index function?
What do you think the index function does?
What is the difference between a GET and a POST request? Why would we need to differentiate between them in a view?
Explanation
The single argument being passed to the index function is request. This is an object containing details about the request that is being processed by the view. For example, whether the request was a GET or POST Method.
In this code, we return a different response based on the request method. method is one of the properties set in the request object.
A GET request is used for retrieving information, like GETting the HTML content of a page. A POST request is used to send something back to the server, like form data. If data is POSTed to the view, we would want to process it in some way or write it to a database, so we need to handle GET and POST requests differently.
The request & response objects
The first argument passed into a view function represents the HTTP request object. By default, we call this parameter request, but you could call it anything you like.

The request object is one of the ways that Django transfers the state throughout the system. In programming, state is a program or application’s temporary data at a given moment in time.

A view receives data from the browser through the request object and returns it through a response object.

Let’s look at those in more detail.

The request object
The HTTP request object contains metadata about the request made to the browser. This includes the request method, as noted above. It also includes any form data, the URL that was called, and any files that were uploaded, among other things.

The view can then use the information in the request object to complete a task, such as writing form data to the database.

For a full list of the contents of the request object, you can check the Django documentation.

The response object
Finally, each view must return a response object to the browser. In our simple example, we have returned a simple HttpResponse. In future lessons, we will return HTML templates, which can contain variables and data.

Test your knowledge
Using what you have learned, modify the index function in the hello_world/views.py file.

Adjust the view so that if the request method is POST, a HttpResponse is returned, that says, "You must have POSTed something".
Otherwise, return an HttpResponse so that, instead of plain text, we return the method of the request object.
Solution
def index(request):

    if request.method == "POST":
        return HttpResponse("You must have POSTed something")
    else:
        return HttpResponse(request.method)
Review
Views contain the code needed to create, read, update and delete database records and to display dynamic content to the user. They are a fundamental part of Django.

This concludes the first part of our deep dive into a simple Django app.

Note: Remember to commit and push your code.


Transcript of video lecture - Important
The content of this video has some high level explanations and  helped my understand the concepts. I would love some visual represntations of the core concepts and flows. These can be simple in nature. 

Start of transcript. Skip to the end.
Congratulations, you have just built a simple, working Django app!
It can be difficult to understand how everything in Django connects together, so in this video,
we will bring together everything we discussed in the previous topics.
In our steps and deeper dive, you have learned how to create a very basic Django project
and some simple, but functional, apps.
The steps for creating projects with apps are the same, so we would recommend practicing
these until they become part of your muscle memory.
Although Django is a complicated batteries-included framework, the underlying principles are very simple.
A project, as we said, is a kind of top-level container for one or more apps.
Inside the project, each app should handle a single piece of functionality, like a blog,
a poll or an online shop.
We’ll look at how we divide up a project into conceptual apps in more detail later.
In our app, we built a simple view, which returns a simple message.
We then wired it up with a URL so that it has, what we call, a route which can be accessed
using a browser.
Let’s consider those in more detail.
When you type python3 manage.py runserver, Django runs a server that listens for requests.
When it receives a request, Django needs to know how to route it.
Routing means looking at the URL typed by the user and determining what content to return.
For example, if we just type in our URL for the about page, Django needs to know what
to return for the about page view, as we can see here.
If the URL is valid, then Django knows from our urls.py file which view code to run.
In the example of the about page, it runs this code.
As we know, this returns some simple text.
When Django has determined what content to return for a particular route, then it needs
to render the result.
This involves sending HTML to the browser.
In our small example, we just sent back “Hello, World” or "This is the about page."
Usually, though, we would use a HTML template.
Internally, then, the process looks like this: In our “Process the correct views.py”
box, a lot can happen.
So far, our view is just a simple HTTP response, but as you will soon see, a view can create,
read, update or delete database records and return complex content.
It can accept all HTTP request methods.
You already know the common ones, such as GET and POST, but all methods are supported
including PUT, EDIT and DELETE.
Getting Django to display simple content is quite straightforward when we understand how
the different files work.
In summary, then, Django makes development easier by breaking everything up into logical
components, which form the basic building blocks of complex web applications.
Creating a Django app is a similar process each time.
You create a project and then an app.
Inside the app, you create a view and a URL for it.
For more advanced projects, you would also include reading from and writing to a database.
Now that we understand how a simple view works, let’s deploy our project to a cloud-based
hosting platform.
Then, we will be equipped to start building a more complex project.

In addition to the notes, I would like a separate section at the bottem that has a basic step by step instructions for starting a django project. 